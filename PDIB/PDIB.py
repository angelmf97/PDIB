#!/usr/bin/env python
# coding=utf-8


import argparse
import re
import os
import logging
import sys
import glob
import random
import string
import numpy as np
from process_input_files import *
from main_functions import *
from compute_energy import *


parser = argparse.ArgumentParser(description='Make protein origami and stuff.')


parser.add_argument( '-i', '--input-directory',
    dest = "input_directory",
    action = "store",
    default = "./",
    help = "Input directory containing files")

parser.add_argument('-o', '--output-directory',
    dest = 'output_directory',
    action = "store",
    default = "./",
    required = True,
    help = "Output directory to store the models")

parser.add_argument('-f', '--force',
    dest = 'force',
    action = 'store_true',
    default = False,
    help = "If it is True, the program can overwrite all the content of the output directory")

parser.add_argument('-v', '--verbose',
    dest = 'verbose',
    action = 'store_true',
    default = False,
    help = "Gives information during the execution of the script")

parser.add_argument('-exh', '--exhaustive',
    dest="exhaustive",
    action="store_true",
    default=False,
    help="Try all the possibilities. It may take a long time!")

parser.add_argument('-sto', '--stoichiometry',
   dest="stoich",
   action="store",
   default=None,
   help="Add a tabular file with sequence ID and stoichiometry")

parser.add_argument('-n_models', '--number-of-models',
   dest="num_models",
   type=int,
   action="store",
   default=1,
   help="Number of models (an integer) to be generated by the pipeline")

parser.add_argument('-n_chains', '--number-of-chains',
   dest="num_chains",
   type=int,
   action="store",
   default=1000,
   help="Maximum number of chains that a model should have")

parser.add_argument('-e', '--energies',
   dest="energies",
   action="store_true",
   help="Compute the energies of the resulting models and their z-scores")

parser.add_argument('-r', '--refine',
   dest="refine",
   action="store_true",
   help="Makes use of PyRosetta in order to improve the obtained models")

args = parser.parse_args() # list of arguments

if args.verbose:
    logging.basicConfig(
        stream=sys.stderr,
        level=logging.DEBUG,
        format = '%(asctime)s %(message)s',
        datefmt='%m/%d/%Y %H:%M:%S')

regex = re.compile(".*\w+_\w+_\w+.pdb(.gz)*")


input_dir = args.input_directory #read input directory

# Check if input is a directory and if True, save files matching the regex in a list
if os.path.isdir(input_dir):
    list_files = [ os.path.join(input_dir, f) for f in os.listdir(input_dir) if regex.match(f)]

    if len(os.listdir(input_dir)) == 0:
        raise ValueError("Input folder is empty")

    elif len(list_files) == 0:
        raise ValueError("Input must be of the format <name>_<chain1>_<chain2>.pdb(.gz)")

elif os.path.isfile(input_dir):
    raise ValueError("Input must be a directory")

if args.verbose:
    sys.stderr.write("%d input files found.\n" %len(list_files))

# Generate the output folders in case they do not exist and the force option is activated
if not os.path.isdir(args.output_directory) or args.force:
    os.makedirs("./%s/structures" % args.output_directory, exist_ok = True)
    os.makedirs("./%s/analysis" % args.output_directory, exist_ok = True)

else:
    raise OSError("%s already exists, specify a different output directory or enable option -f to override the already existing one." % args.output_directory)

info_files, info_seqs = process_input(list_files)

stoichiometry = None
if args.stoich:
    stoichiometry = get_stoichiometry(args.stoich)  

parser = PDBParser(PERMISSIVE=1)

first_file = random.choice(list(info_files.keys()))
first_structure = parser.get_structure("structure", first_file)

# change the chain id names
for chain in first_structure.get_chains():
    original_id = chain.id  # the so-called chain accession, usually a letter (A,B,C,D ...)
    chain.id = [x for x in info_files[first_file] if x[0] == original_id][0]

final_models = []

final_models = create_model(first_structure, final_models, info_files, args.num_chains, args.num_models, args.exhaustive, stoich=stoichiometry, verbose=False)


if len(final_models) == 0:
    # if options.stoich:
    #     sys.stderr.write("No complex could be obtained with your specified stoichiometry. We recommend specifying a number of models to explore (-n_models) or run the default pipeline (as sometimes the obtained stoichiometry is very similar to the expected). \n")
    # else:
        sys.stderr.write("No complex could be obtained with the provided files. \n")

chain_alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S",
            "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l"
            , "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4"
            , "5", "6", "7", "8", "9"]

model_paths = []
for final_model in final_models:

    # if final model has more than 62 chains, split into different models
    structure = pdb_struct.Structure('id')  # empty structure:

    # create a new model for each group of 62 chains, and add to structure and change the id of the chains and record the info about which is the molecule of each chain
    chain_counter = 0
    model_counter = 0
    legend = ""

    # change the ids of the chains to completely random, for further
    chains = list(final_model.get_chains())

    for chain in chains:

        # define the new id:
        new_id = chain_alphabet[chain_counter]

        # update what has to be printed:
        legend += 'CHAIN    %s   %s   %s\n' % (new_id, chain.id[1], info_seqs[chain.id[1]])

        # change to the new id
        chain.id = new_id

        # improve the chain counter
        chain_counter += 1

        # if options.verbose:
        #     print('printing chain: ', chain_counter, chain.id)

        # initialize model
        if chain_counter == 1:
            model_counter += 1
            model = pdb_model.Model(model_counter)

        # add chain to the model
        model.add(chain)

        # reset counter and add model after 62 rounds
        if chain_counter == len(chain_alphabet):
            chain_counter = 0

            model = model.copy()
            structure.add(model)

            # remove the chains in the current model of  of the final_model, to avoid further problems with the id
            for chain_m in model.get_chains():
                final_model[0].detach_child(chain_m.id)

    # add the last model:
    current_models_strcuture = [x.id for x in structure.get_models()]
    if model.id not in current_models_strcuture:
        structure.add(model)

    # define the name of the model, not to overwrite previous existing files
    written_id = 0
    PDB_name = 'model_' + str(written_id) + '.pdb'
    while PDB_name in  os.listdir(args.output_directory) :
        written_id += 1
        PDB_name = 'model_'+str(written_id)+'.pdb'

    # if options.verbose:
    #     print('%s created as a model for the complex structure.' % PDB_name)

    # open the pdb and put information about what is each chain
    model_path = args.output_directory + "/structures/" + PDB_name
    model_paths.append(model_path) ### OJO

    # Write the ATOM lines:
    io = PDBIO()  # using our own PDB writer
    io.set_structure(structure)
    io.save(model_path)

    # write the info lines
    fd = open(model_path, 'a')
    fd.write('CHAIN HEADER    current id   molecule id    sequence\n')
    fd.write(legend)
    fd.write('\n')
    fd.close()

import shutil
shutil.rmtree("PDIB_tmp")

if args.refine:
    try:
        from refine import *
    
    except ModuleNotFoundError:
        logging.warning("Module PyRossetta not installed. No refined models will be generated.")
    
    else:
        os.makedirs("./%s/refined" % args.output_directory, exist_ok = True)
        for path in model_paths:

            refine(path, args.output_directory, logging)
            model_paths.append(path)

if args.energies:
    compute_energy(model_paths, args.output_directory, logging)

