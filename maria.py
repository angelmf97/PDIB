#!/usr/bin/env python
# coding=utf-8


import argparse
import re
import os
import logging
import sys
import glob
import random
import string

parser = argparse.ArgumentParser(description='Make protein origami and stuff.')


parser.add_argument( '-i', '--input-directory',
                    dest = "input_directory",
                    action = "store",
                    default = "./",
                    help = "Input directory containing files")

parser.add_argument('-o', '--output-directory',
                    dest = 'output_directory',
                    action = "store",
                    default = "./",
                    required = True,
                    help = "Output directory to store the models")

parser.add_argument('-f', '--force',
                    dest = 'force',
                    action = 'store_true',
                    default = False,
                    help = "If it is True, the program can overwrite all the content of the output directory")

parser.add_argument('-v', '--verbose',
                    dest = 'verbose',
                    action = 'store_true',
                    default = False,
                    help = "Gives information during the execution of the script")

parser.add_argument('-exh', '--exhaustive',
   dest="exhaustive",
   action="store_true",
   default=False,
   help="Try all the possibilities. It may take a long time!")

parser.add_argument('-sto', '--stoichiometry',
   dest="stoich",
   action="store",
   default=None,
   help="Add a tabular file with sequence ID and stoichiometry")

parser.add_argument('-n_models', '--number-of-models',
   dest="num_models",
   type=int,
   action="store",
   default=1,
   help="Number of models (an integer) to be generated by the pipeline")

parser.add_argument('-n_chains', '--number-of-chains',
   dest="num_chains",
   type=int,
   action="store",
   default=1000,
   help="Maximum number of chains that a model should have")

args = parser.parse_args() # list of arguments

if args.verbose:
    logging.basicConfig(stream=sys.stderr,
                        level=logging.DEBUG,
                        format = '%(asctime)s %(message)s',
                        datefmt='%m/%d/%Y %H:%M:%S')

regex = re.compile(".*\w+_\w+_\w+.pdb(.gz)*")


input_dir = args.input_directory #read input directory

# Check if input is a directory and if True, save files matching the regex in a list
if os.path.isdir(input_dir):
    list_files = [ os.path.join(input_dir, f) for f in os.listdir(input_dir) if regex.match(f)]

    if len(os.listdir(input_dir)) == 0:
        raise ValueError("Input folder is empty")

    elif len(list_files) == 0:
        raise ValueError("Input must be of the format <name>_<chain1>_<chain2>.pdb(.gz)")

elif os.path.isfile(input_dir):
    raise ValueError("Input must be a directory")

if args.verbose:
    sys.stderr.write("%d input files found.\n" %len(list_files))

# Generate the output folders in case they do not exist and the force option is activated
if not os.path.isdir(args.output_directory) or args.force:
    os.makedirs("./%s/structures" % args.output_directory, exist_ok = True)
    os.makedirs("./%s/analysis" % args.output_directory, exist_ok = True)

else:
    raise OSError("%s already exists, specify a different output directory or enable option -f to override the already existing one." % args.output_directory)



from Bio.PDB.Superimposer import Superimposer
from Bio.PDB.PDBParser import PDBParser
from Bio.PDB.Polypeptide import PPBuilder
from Bio.PDB import NeighborSearch
from Bio import pairwise2
from Bio.PDB import Structure as pdb_struct
from Bio.PDB import Model as pdb_model
from Bio.PDB import PDBIO
ppb = PPBuilder()
parser = PDBParser(PERMISSIVE = True, QUIET = True)

def id_generator (n, chars=string.ascii_uppercase + string.digits):
    """Generates a random ID of n number of elements."""
    return ''.join(random.choice(chars) for _ in range(n))

def process_input (list_files):
    """Process input generating two dictionaries from a list of PDB files.
    The info_seqs dictionary contains unique sequences as values and the key is the new ID assigned to this unique sequence.
    The info_files dictionary has, as key, the name of the file and as value a list of tuples (one for each of the chains)
    with the original chain ID found in the file and the new ID assigned to this unique sequence."""

    info_files = {}
    info_seqs = {}

    # loop through files found in the list of files
    for filename in list_files:

        structure = parser.get_structure("structure", filename) # get the structure of the PDB file

        n_chains = len(structure[0].child_list)

        if n_chains != 2:
            # ESTE ERROR INCLUYE EL ARCHIVO EN INFO_FILES? HABRÍA QUE QUITARLO
            logging.error("There should be 2 chains in the pdb file. %d chains found in %s instead." % (n_chains, filename))
            continue


        chains = list(structure.get_chains())

        match_IDs = [] # it will contain a tuple for each of the chains of the file with the original ID and the new ID assigned to it

        # loop through chains of the current file
        for chain in chains:
            print(chain.id)
            sequence = "".join([str(pp.get_sequence()) for pp in ppb.build_peptides(chain)])

            # if sequence is still empty it may be because it is a DNA sequence instead of a nucleotide one
            if sequence  == "":
                sequence = "".join([nt.resname[2] for nt in chain.get_residues() if nt.resname[2] in 'ACGTU' and len(nt.resname) == 3])

            ## HABRÍA QUE COMPROBAR QUE LA SECUENCIA YA NO ESTÁ VACÍA

            # assign a unique ID to the sequence
            seq_id = None
            identity_threshold = 95 # identity threshold for which above it sequences will be considered the same
            highest_identity = identity_threshold

            # if info_seqs is not empty, loop through each of the keys to align the current sequence with the ones stored in this dict.
            if info_seqs:
                for chain_id in info_seqs:

                    # align my sequence with all the ones stored in the info_seqs
                    alignment = pairwise2.align.globalxx(sequence, info_seqs[chain_id])

                    # calculate the percentage identity in the alignment
                    match_percent = (alignment[0][2] / min(len(sequence), len(info_seqs[chain_id]))) * 100

                    if match_percent > identity_threshold:
                        seq_id = chain_id # assign the same ID
                        highest_identity = match_percent # update the highest identity

                # if sequences are not considered the same, assign a new ID to it and make sure this ID as a key is unique in the info_seqs dict
                if seq_id is None:
                    n = 0
                    while n < 1:
                        seq_id = id_generator(6)
                        if seq_id not in info_seqs:
                            n = 1
                            info_seqs[seq_id] = sequence
                        else:
                            n = 0

            # if the info_seqs is still empty, add the sequence and generate a random ID to it
            else:
                seq_id = id_generator(6)
                info_seqs[seq_id] = sequence

            # create the tuple of original ID and new ID for each of the chains of the file
            ids = (chain.id, seq_id)
            match_IDs.append(ids)

        # save info of each file in the files_info dictionary
        info_files[filename] = match_IDs

    return info_files, info_seqs

info_files, info_seqs = process_input(list_files)

def get_stoichiometry(path):
    """Converts the stoichiometry file to a dictionary"""
    
    st_dict = {}
    with open(path) as fh:
    
        for line in fh:
            if re.match('\s*\w+\s*(:|=)\s*\d+', line):
                splitted = re.split('(:|=)', line)
                st_dict[splitted[0].strip()] = int(splitted[2].strip())
            else:
                logging.warning('The stoichiometry file must follow the format "Chain : number of repeats". Each chain must be separated by a line break. Error found in line "%s"' % line.strip())
    
    return st_dict

stoichiometry = None
if args.stoich:
    stoichiometry = get_stoichiometry(args.stoich)    


def superimpose(chainA, chainB, moving = None):

    """Superimpose one chain of a structure with an equivalent chain  chains and add another with the rotation parameters obtained. Return structure object with added chain, information about clashes and a flag for having added something.
    Keyword arguments:
    eq_chain1 -- common chain in the current structure (curr_struct)
    eq_chain2 -- common chain in the structure from which a chain wants to be added (moving_chain)
    moving_chain -- chain that may be added to the current complex
    rec_level_complex -- recursion level of building the complex
    filename2 -- name of the file that contains the moving_chain """

    residuesA = list(chainA.get_residues())
    residuesB = list(chainA.get_residues())

    # filter non-standard residues or errors
    filteredA = [res for res in residuesA if ('CA' in res or 'P' in res)]
    filteredB = [res for res in residuesB if ('CA' in res or 'P' in res)]

    # superimposer will try to pair atoms to move them from the position in one chain to the other, so it is important to have the same number of atoms
    if len(filteredA) > len(filteredB):
        filteredA = filteredA[:len(filteredB)]
    elif len(filteredA) < len(filteredB):
        filteredB = filteredB[:len(filteredA)]

    atomsA = []
    for res in filteredA:
        for atom in res.get_atoms():
            if atom.id == 'CA' or atom.id == 'P':
                atomsA.append(atom)
                break

    atomsB = []
    for res in filteredB:
        for atom in res.get_atoms():
            if atom.id == 'CA' or atom.id == 'P':
                atomsB.append(atom)
                break

    
    superimposer = Superimposer()

    superimposer.set_atoms(atomsA, atomsB)

    rmsd = superimposer.rms

    if moving:
        superimposer.apply(list(moving.get_atoms()))
        return rmsd, moving

    return rmsd    


def check_clash(model, chain_to_add, clash_distance=2.5):

    """Check if there is a steric clash between a rotating chain and current structure. Return False (no clash), 1 (clash between two different chains) or 2 (same chain). Also returns the ids of the chains in structure that are clashing
    Keyword arguments:
    structure -- whole structure
    rotating_chain -- chain to be analyzed with respect to structure
    distance_for_clash -- threshold to consider clash between atoms. Default = 2.5 (Armstrongs)
    Clash criteria: at least 20 of the atoms are at a lower distance than distance_for_clash
    Same chain criteria: RMSD between them <= 3.0 """

    # initialize the neighbor search
    neighbor_object = NeighborSearch(list(model.get_atoms()))

    structure_clashing_chains = set() # It is important that it is a set because no duplicates
    total_clashes = 0

    for atom in chain_to_add.get_atoms():
        clashes = neighbor_object.search(atom.get_coord(), clash_distance)
        if len(clashes) > 0:
            for clash in clashes:
                structure_clashing_chains.add(clash.get_parent().get_parent().id)
                total_clashes += 1 # Number of atoms that clash
    
    if len(structure_clashing_chains) > 1 and total_clashes > 20:
        # a clash against different chains:
        return structure_clashing_chains, False
    
    elif len(structure_clashing_chains) == 1 and total_clashes > 20 and chain_to_add.id[1] == list(structure_clashing_chains)[0][1]:

        # a clash MAYBE because you are trying to superimpose something in the place it was already

        # define the clashing chain:
        clash_chain = model[0][list(structure_clashing_chains)[0]]
        RMSD = superimpose(clash_chain, chain_to_add)

        if RMSD <= 3.0:
            # it is the same chain
            return structure_clashing_chains, True

        else:
            # it is another chain or the same with different structure
            return structure_clashing_chains, False

    elif total_clashes > 20:
        # it is ine chain and the previous conditions are not fullfilled
        return structure_clashing_chains, False

    else:
        # no clash
        return None, False

def check_structure_exists(structure, all_structures):

    """Ask if structure is already in created_structures (a list of structures). Returns a boolean.
    Considerations:
    Return True if all of the chains in structure are in one of the structures in created_structures and RMSD <= 3.0, meaning they are the same structure """

    # make a deepcopy of these objects
    structure = structure.copy()
    all_structures = all_structures.copy()

    # Get the ids of the chains in structure
    chain_ids_structure = tuple(sorted([x.id[1] for x in structure.get_chains()]))

    # loop through each of the contents of created_structures:
    for each_structure in all_structures:

        # get the chains of created_structure
        chain_ids_each_structure = tuple(sorted([x.id[1] for x in each_structure.get_chains()]))

        # ask if the number of each and ids of the chains are the same:
        if chain_ids_structure == chain_ids_each_structure:

            # pick one chain in structure to compare with the chains in created
            chain_str = list(structure.get_chains())[0]
            id_str = chain_str.id[1]

            # try to find a partner in created_structure:
            for chain_each_str in each_structure.get_chains():

                id_each_str = chain_each_str.id[1]

                # if they have the same id they are potential partners. Superimpose these next. The id_created_str has also to be avaliable in possible_partners
                if id_str == id_each_str:

                    RMSD, structure = superimpose(chain_str, chain_each_str, structure)

                    # if I have superimposed same ID but different structure, try another chain
                    if  RMSD > 3.0:
                        continue

                    # if the previous chain_str and chain_created_str are real partners they should also result in haveing all they cross-superimposed chains with partners
                    partners = set()

                    for searching_partner in each_structure.get_chains():
                        partner_found = False

                        for possible_partner in structure.get_chains():

                            if partner_found is True:
                                break

                            if possible_partner.id[1] == searching_partner.id[1] and possible_partner not in partners:

                                    RMSD = superimpose(searching_partner, possible_partner)

                                    if RMSD <= 3.0:
                                        partners.add(possible_partner)
                                        partner_found = True

                        if len(partners) == len(list(created_structure.get_chains())):
                            return True  # all chains have a partner, which means that the structure is in the created_structures

    # if you didn't find any match return false:
    return False    

def create_model(current_structure, stored_structures, info_files, num_chains, num_models, exhaustive, tree_level = 0, climb = False, in_a_branch = False, non_brancheable_clashes=set(), tried_branch_structures=list(), stoich=None, verbose=False):

    """Build model
    AÑADIR MÁS INFO"""

    # 
    if exhaustive is False and num_models == len(stored_structures):
        return stored_structures

    if climb:
        tree_level += 1

    # files that have to be used. The shuffle is for generating alternative paths, so that running the program many times may generate slightly different resukts
    all_files= list(info_files.keys())
    random.shuffle(all_files)


    # # a boolean that indicates if there's something added at this level
    something_added = False

    # #    POSIBLES MEJORAS print the conformation of the current complex:
    # if verbose:
    #     print_topology_of_complex(current_str)

    current_chains = list(current_structure.get_chains())

    # iterate through the chains of the current structure
    for structure_chain in current_chains:

        # when I climb the tree, I only want to add chains to those added in the previous node
        # If I am in a branch, I have not added but replaced a chain. Therefore, I still want to add a chain in the same node
        # This way we are not doing not necessary comparison

        if (climb and structure_chain.id[-1] != str(tree_level-1)) or (in_a_branch and structure_chain.id[-1] != str(tree_level)):
            continue

        # if verbose:
        #     print('Trying to add chains through the common chain: ', chain1.id)

        # iterate through the PDB files of the directory to compare them to the current struct
        for file in all_files:

            # initialize the common and rotating chain
            moving_chain = None
            equeal_chain = None

            ## AÑADIR AQUÍ QUE 

            # if the chain id of the current structure is found in the second PDB file:
            if structure_chain.id[1] in [x[1] for x in info_files[file]]:

                # get the structure
                structure_to_add = parser.get_structure("structure", file) 

                # change the chain id to our format
                for chain in structure_to_add.get_chains():
                    original_id = chain.id
                    chain.id = [x for x in info_files[file] if x[0] == original_id][0]

                # if it is a homodimer set both pssibilities of rotating / common

                if info_files[file][0][1] == info_files[file][1][1]:

                    # generate an array with the two possibilities
                    moving_chains = [structure_to_add[0][info_files[file][0]], structure_to_add[0][info_files[file][1]]]
                    common_chains = [structure_to_add[0][info_files[file][1]], structure_to_add[0][info_files[file][0]]]

                else:
                    # decide which is (rotating / common)
                    for chain in structure_to_add.get_chains():

                        if structure_chain.id[1] == chain.id[1]:
                            common_chains = [chain]
                        else:
                            moving_chains = [chain]

                # go through each possible rotating and common chains

                for i in range(len(common_chains)):

                    # define each of the rotating/common, without perturbing the original ones
                    if len(moving_chains) > 1:
                        moving_chain = moving_chains[i].copy()
                        common_chain = common_chains[i].copy()
                    else:
                        moving_chain = moving_chains[i]
                        common_chain = common_chains[i]

                    RMSD, moved_chain = superimpose(structure_chain, common_chain, moving_chain)
                    clashing_chains, same_chain= check_clash(current_structure, moved_chain)

                    # something is added if there's no clashes and the RMSD is very low, indicating that the two chains are actually the same
                    added = False
                    if not clashing_chains and RMSD <= 3.0:
                        partial_id = moved_chain.id
                        existing_names = [x.id for x in current_structure[0].get_chains()]
                        while not added:
                            random_id = (id_generator(6),str(tree_level)) # random ID + a number that indicates the recursion level at which this chain has been added
                            if partial_id + random_id not in existing_names:
                                moved_chain.id = tuple(list(partial_id) + list(random_id))
                                current_structure[0].add(moved_chain)
                                added = True


                    # when there's a aberrant clash and you fulfill one of the branch-opening  conditions
                    if clashing_chains and not same_chain and (exhaustive or num_models > 1 or stoich):

                        # a branch complex will be created if the rotating chain is not one of the previously branch-opening clashing chains
                        # or if the clashes happen against the chain that opened this branch

                        open_branch = False

                        if in_a_branch:

                            clash_ids = set([(x, moved.id[1]) for x in clashing_chains])
                            # check if the clashes are not an exception
                            if len(non_brancheable_clashes.intersection(clash_ids)) == 0:
                                open_branch = True

                        else:
                            open_branch = True

                        if open_branch:

                            # set the id of the chain you were trying to add:
                            added_chain = moved_chain.copy()
                            added_chain.id = tuple(list(added_chain.id) + [id_generator(6), str(tree_level)])

                            # make a new branch:
                            branch_structure = current_structure.copy()

                            # remove the chains that chains that are clashing:
                            for clashing_chain in clashing_chains:
                                branch_structure[0].detach_child(clashing_chain)

                            # create a set of tuples (added_chain, clashing_chains_ids) of branch opening exceptions
                            for x in clashing_chains:
                                non_brancheable_clashes.add((added_chain.id, x[1]))

                            # add the chain that was clashing:
                            branch_structure[0].add(added_chain)

                            # check if the branch_new_str is not in tried_branch_structures:
                            if check_structure_exists(branch_structure, tried_branch_structures) is False:

                                # indicate that a branch is opening
                                if verbose:
                                    print('%s of %s  clashes against the complex. Opening a new branch...' % (added_chain.id[1], file))

                                # add this branch to the ones already tested:
                                tried_branch_structures.append(branch_structure)

                                # create a new structure based on this branch:
                                stored_structures = create_model(branch_structure, stored_structures, info_files, num_chains, num_models, exhaustive, tree_level = tree_level, in_a_branch = True, non_brancheable_clashes=non_brancheable_clashes,
                                    tried_branch_structures=tried_branch_structures, stoich=stoich, verbose=verbose)

                                # return as soon as possible:
                                if exhaustive is False and num_models == len(stored_structures):
                                    return stored_structures

    if added and len(list(current_structure.get_chains())) <= num_chains:

        if in_a_branch:
            stored_structures = create_model(current_structure, stored_structures, info_files, num_chains, num_models, exhaustive, tree_level = tree_level, climb = True, in_a_branch = True, non_brancheable_clashes=non_brancheable_clashes,
                tried_branch_structures=tried_branch_structures, stoich=stoich, verbose=verbose)
        else:
            stored_structures = create_model(current_structure, stored_structures, info_files, num_chains, num_models, exhaustive, tree_level = tree_level, climb = True, in_a_branch = False, non_brancheable_clashes=non_brancheable_clashes,
                tried_branch_structures=tried_branch_structures, stoich=stoich, verbose=verbose)


        # return as soon as possible:
        if exhaustive is False and num_models == len(stored_structures):
            return stored_structures

    else:
        if verbose:
            print("trying to save model")

        # check stoichiometry
        if stoich:
            final_stoich = {}
            for chain in current_structure.get_chains():
                chain_id = chain.id[1]

                if chain_id not in final_stoich:
                    final_stoich[chain_id] = 1
                else:
                    final_stoich[chain_id] += 1

            divisors = set()
            for key, value in final_stoich.items():
                divisor = value / stoich[key]
                divisors.add(divisor)

            if len(divisors) == 1 and check_structure_exists(current_structure, stored_structures) is False:
                stored_structures.append(current_structure)

                # if verbose:
                #     print("saving model")
                #     print_topology_of_complex(current_str)
                #     print('\n\n')

        elif check_structure_exists(current_structure, stored_structures) is False:

            stored_structures.append(current_structure)
            # if verbose:
            #     print("saving model")
            #     print_topology_of_complex(current_str)
            #     print('\n')

    return stored_structures

first_file = random.choice(list(info_files.keys()))
first_structure = parser.get_structure("structure", first_file)

# change the chain id names
for chain in first_structure.get_chains():
    original_id = chain.id  # the so-called chain accession, usually a letter (A,B,C,D ...)
    chain.id = [x for x in info_files[first_file] if x[0] == original_id][0]

final_models = []

final_models = create_model(first_structure, final_models, info_files, args.num_chains, args.num_models, args.exhaustive, stoich=stoichiometry, verbose=False)


if len(final_models) == 0:
    # if options.stoich:
    #     sys.stderr.write("No complex could be obtained with your specified stoichiometry. We recommend specifying a number of models to explore (-n_models) or run the default pipeline (as sometimes the obtained stoichiometry is very similar to the expected). \n")
    # else:
        sys.stderr.write("No complex could be obtained with the provided files. \n")


chain_alphabet = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S",
            "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l"
            , "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4"
            , "5", "6", "7", "8", "9"]

for final_model in final_models:

    # if final model has more than 62 chains, split into different models
    structure = pdb_struct.Structure('id')  # empty structure:

    # create a new model for each group of 62 chains, and add to structure and change the id of the chains and record the info about which is the molecule of each chain
    chain_counter = 0
    model_counter = 0
    legend = ""

    # change the ids of the chains to completely random, for further
    chains = list(final_model.get_chains())

    for chain in chains:

        # define the new id:
        new_id = chain_alphabet[chain_counter]

        # update what has to be printed:
        legend += 'CHAIN    %s   %s   %s\n' % (new_id, chain.id[1], info_seqs[chain.id[1]])

        # change to the new id
        chain.id = new_id

        # improve the chain counter
        chain_counter += 1

        # if options.verbose:
        #     print('printing chain: ', chain_counter, chain.id)

        # initialize model
        if chain_counter == 1:
            model_counter += 1
            model = pdb_model.Model(model_counter)

        # add chain to the model
        model.add(chain)

        # reset counter and add model after 62 rounds
        if chain_counter == len(chain_alphabet):
            chain_counter = 0

            model = model.copy()
            structure.add(model)

            # remove the chains in the current model of  of the final_model, to avoid further problems with the id
            for chain_m in model.get_chains():
                final_model[0].detach_child(chain_m.id)

    # add the last model:
    current_models_strcuture = [x.id for x in structure.get_models()]
    if model.id not in current_models_strcuture:
        structure.add(model)

    # define the name of the model, not to overwrite previous existing files
    written_id = 0
    PDB_name = 'model_' + str(written_id) + '.pdb'
    while PDB_name in  os.listdir(args.output_directory) :
        written_id += 1
        PDB_name = 'model_'+str(written_id)+'.pdb'

    # if options.verbose:
    #     print('%s created as a model for the complex structure.' % PDB_name)

    # open the pdb and put information about what is each chain
    model_path = args.output_directory + PDB_name

    # Write the ATOM lines:
    io = PDBIO()  # using our own PDB writer
    io.set_structure(structure)
    io.save(model_path)

    # write the info lines
    fd = open(model_path, 'a')
    fd.write('CHAIN HEADER    current id   molecule id    sequence\n')
    fd.write(legend)
    fd.write('\n')
    fd.close()